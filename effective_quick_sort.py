"""Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров. Задачи
подобраны, участники зарегистрированы, тесты написаны. Осталось придумать, как в конце соревнования будет
определяться победитель.

Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два показателя:
количество решённых задач Pi и размер штрафа Fi. Штраф начисляется за неудачные попытки и время, затраченное на задачу.

Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот,
у которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом. Если же и
штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.

Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. В своё отсутствие он поручил вам
реализовать алгоритм быстрой сортировки (англ. quick sort) для таблицы результатов. Так как Тимофей любит спортивное
программирование и не любит зря расходовать оперативную память, то ваша реализация сортировки не может потреблять O(
n) дополнительной памяти для промежуточных данных (такая модификация быстрой сортировки называется "in-place").

Формат ввода
В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
В каждой из следующих n строк задана информация про одного из участников.
i-й участник описывается тремя параметрами:
уникальным логином (строкой из маленьких латинских букв длиной не более 20)
числом решённых задач Pi
штрафом Fi
Fi и Pi — целые числа, лежащие в диапазоне от 0 до 109.

Формат вывода
Для отсортированного списка участников выведите по порядку их логины по одному в строке."""


def quicksort(array):
    def partition(left, right):
        pivot = array[right]
        divider = left - 1
        for current in range(left, right):
            if array[current] < pivot:
                divider += 1
                array[divider], array[current] = array[current], array[divider]
        array[divider + 1], array[right] = array[right], array[divider + 1]
        return divider + 1

    def quicksort_inside(left, right):
        if left < right:
            divider = partition(left, right)
            quicksort_inside(left, divider - 1)
            quicksort_inside(divider + 1, right)

    quicksort_inside(0, len(array) - 1)
    return array


if __name__ == '__main__':
    print(*[participant[2] for participant in
            quicksort([(lambda login, task_count, fine: (-int(task_count),
                                                         int(fine),
                                                         login))(*input().split(' '))
                       for _ in range(int(input()))])], sep='\n')
